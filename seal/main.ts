import homeDir from "https://deno.land/x/dir@1.5.1/home_dir/mod.ts";
import * as path from "https://deno.land/std@0.204.0/path/mod.ts";
import * as infer from "npm:deno-infer@1.0.5";

type Permission = { allowed: boolean; entries?: string[] };
type PermissionType = "read" | "write" | "run" | "net" | "ffi" | "env";

export class Program {
  path: string;
  originalCmd: string;
  parts: string[];

  constructor(path: string) {
    const { cmd, parts } = Program._parseEntry(path);
    this.path = path;
    this.originalCmd = cmd;
    this.parts = parts;
  }
  static _parseEntry(entry: string) {
    const content = Deno.readTextFileSync(entry);
    const cmd = content.split("\n").find((line) => line.startsWith("exec"));
    if (cmd === undefined) {
      throw new Error(
        "malformed program: " + entry + "\n" + "content: " + content,
      );
    }

    const parts = cmd.split(/\s+/);
    return { cmd, parts };
  }

  read() {
    return this._parsePermission("--allow-read");
  }
  setRead(permissionSet: Permission) {
    this._setPermission("read", permissionSet);
    return this;
  }
  write() {
    return this._parsePermission("--allow-write");
  }
  setWrite(permission: Permission) {
    this._setPermission("write", permission);
    return this;
  }
  run() {
    return this._parsePermission("--allow-run");
  }
  setRun(permission: Permission) {
    this._setPermission("run", permission);
    return this;
  }
  env() {
    return this._parsePermission("--allow-env");
  }
  setEnv(permission: Permission) {
    this._setPermission("env", permission);
    return this;
  }
  net() {
    return this._parsePermission("--allow-net");
  }
  setNet(permission: Permission) {
    this._setPermission("net", permission);
    return this;
  }
  ffi() {
    return this._parsePermission("--allow-ffi");
  }
  setFfi(permission: Permission) {
    this._setPermission("ffi", permission);
    return this;
  }

  commit() {
    const newCmd = this.parts.join(" ");
    const newScript = [
      "#!/bin/sh",
      "# generated by deno install",
      newCmd,
    ].join("\n");
    Deno.writeTextFileSync(this.path, newScript);
  }

  _parsePermission(permission: string) {
    const permissionRaw = this.parts.find((part) =>
      part.startsWith(permission)
    );
    if (permissionRaw === undefined) return { allowed: false };
    if (permissionRaw.includes("=")) {
      const allowedEntries = permissionRaw.split("=")[1].split(",");
      return { allowed: true, entries: allowedEntries };
    } else {
      return { allowed: true };
    }
  }

  _setPermission(type: PermissionType, permission: Permission) {
    const typeToPermission = (type: string) => {
      switch (type) {
        case "read":
          return "--allow-read";
        case "write":
          return "--allow-write";
        case "run":
          return "--allow-run";
        case "net":
          return "--allow-net";
        case "ffi":
          return "--allow-ffi";
        case "env":
          return "--allow-env";
        default:
          throw new Error(`type: ${type} not handled`);
      }
    };

    const idx = this.parts.findIndex((part) =>
      part.startsWith(typeToPermission(type))
    );

    if (!permission.allowed) {
      if (idx !== -1) {
        this.parts.splice(idx, 1);
      }
    } else if (permission.allowed) {
      if (idx === -1) {
        if (permission.entries && permission.entries.length > 0) {
          this.parts.splice(
            3,
            0,
            `${typeToPermission(type)}=${permission.entries.join(",")}`,
          );
        } else {
          this.parts.splice(3, 0, typeToPermission(type));
        }
      } else {
        if (permission.entries && permission.entries.length > 0) {
          this.parts.splice(
            3,
            0,
            `${typeToPermission(type)}=${permission.entries.join(",")}`,
          );
        } else {
          this.parts.splice(3, 0, typeToPermission(type));
        }
      }
    }
  }
}

function* getPrograms() {
  const homeDirPath = homeDir();
  if (!homeDirPath) throw "home dir not found";
  const programsDir = Deno.readDirSync(path.join(homeDirPath, ".deno", "bin"));
  for (const entry of programsDir) {
    if (!entry.isFile) continue;
    yield {
      name: entry.name,
      path: path.join(homeDirPath, ".deno", "bin", entry.name),
    };
  }
}

function createProgramMap() {
  const programMap: Record<string, Program> = {};
  for (const entry of getPrograms()) {
    const { name, path } = entry;
    if (getFromPath(path)?.extension() !== "sh") continue;
    const program = new Program(path);
    programMap[name] = program;
  }
  return programMap;
}

//TODO: remove this when infer is fixed
/** Returns the file type of the file given a path. */
export function getFromPath(path: string) {
  const file = Deno.openSync(path, { read: true });
  const limit = Math.min(file.statSync().size, 8192) + 1;
  const bytes = new Uint8Array(limit);
  file.readSync(bytes);
  file.close();

  return infer.get(bytes);
}

if (import.meta.main) {
  const programMap = createProgramMap();
  for (const [n, p] of Object.entries(programMap)) {
    console.log(n);
    console.log("read", p.read());
    console.log("write", p.write());
    console.log("run", p.run());
    console.log("net", p.net());
  }
  programMap["molt"].setRead({ allowed: true, entries: ["/etc/hosts"] });
}
