import homeDir from "https://deno.land/x/dir@1.5.1/home_dir/mod.ts";
import * as path from "jsr:@std/path@1.0.8";
import * as infer from "jsr:@sigmasd/deno-infer@3.0.1";
import assert from "node:assert";

export type Permission = { allowed: boolean; entries?: string[] };
export type PermissionNameWithAll = Deno.PermissionName | "all";

export class Program {
  path: string;
  originalCmd: string;
  parts: string[];

  constructor(path: string) {
    const { cmd, parts } = Program.#parseEntry(path);
    this.path = path;
    this.originalCmd = cmd;
    this.parts = parts;
  }

  static #parseEntry(entry: string) {
    const content = Deno.readTextFileSync(entry);
    const cmd = content.split("\n").find((line) => line.startsWith("exec"));
    if (cmd === undefined) {
      throw new Error(
        `malformed program: ${entry}\ncontent: ${content}`,
      );
    }

    const parts = cmd.split(/\s+/);
    return { cmd, parts };
  }

  setPermissionByName(
    permissionName: PermissionNameWithAll,
    permission: Permission,
  ) {
    switch (permissionName) {
      case "read":
        this.setRead(permission);
        break;
      case "write":
        this.setWrite(permission);
        break;
      case "env":
        this.setEnv(permission);
        break;
      case "ffi":
        this.setFfi(permission);
        break;
      case "net":
        this.setNet(permission);
        break;
      case "run":
        this.setRun(permission);
        break;
      case "sys":
        this.setSys(permission);
        break;
      case "all":
        this.setAll(permission);
        break;
      default:
        throw Error(`unkown permission: ${permissionName}`);
    }
  }
  read(): Permission {
    return this.#parsePermission("--allow-read");
  }
  setRead(permissionSet: Permission) {
    this.#setPermission("read", permissionSet);
    return this;
  }
  write(): Permission {
    return this.#parsePermission("--allow-write");
  }
  setWrite(permission: Permission) {
    this.#setPermission("write", permission);
    return this;
  }
  run(): Permission {
    return this.#parsePermission("--allow-run");
  }
  setRun(permission: Permission) {
    this.#setPermission("run", permission);
    return this;
  }
  env(): Permission {
    return this.#parsePermission("--allow-env");
  }
  setEnv(permission: Permission) {
    this.#setPermission("env", permission);
    return this;
  }
  net(): Permission {
    return this.#parsePermission("--allow-net");
  }
  setNet(permission: Permission) {
    this.#setPermission("net", permission);
    return this;
  }
  sys(): Permission {
    return this.#parsePermission("--allow-sys");
  }
  setSys(permission: Permission) {
    this.#setPermission("sys", permission);
    return this;
  }
  ffi(): Permission {
    return this.#parsePermission("--allow-ffi");
  }
  setFfi(permission: Permission) {
    this.#setPermission("ffi", permission);
    return this;
  }
  all() {
    return this.#parsePermission("--allow-all");
  }
  setAll(permission: Permission) {
    this.#setPermission("all", permission);
    return this;
  }

  commit() {
    const newCmd = this.parts.join(" ");
    const newScript = [
      "#!/bin/sh",
      "# generated by deno install",
      newCmd,
    ].join("\n");
    Deno.writeTextFileSync(this.path, newScript);
  }

  #parsePermission(permission: string) {
    const permissionRaw = this.parts.find((part) =>
      part.startsWith(permission)
    );
    if (permissionRaw === undefined) return { allowed: false };
    if (permissionRaw.includes("=")) {
      const allowedEntries = permissionRaw.split("=")[1].split(",");
      return { allowed: true, entries: allowedEntries };
    }

    return { allowed: true };
  }

  #setPermission(type: PermissionNameWithAll, permission: Permission) {
    const permissionFlag = (() => {
      switch (type) {
        case "read":
          return "--allow-read";
        case "write":
          return "--allow-write";
        case "run":
          return "--allow-run";
        case "net":
          return "--allow-net";
        case "ffi":
          return "--allow-ffi";
        case "env":
          return "--allow-env";
        case "sys":
          return "--allow-sys";
        case "all":
          return "--allow-all";
      }
    })();
    const finalPermissionForm =
      (permission.entries && permission.entries.length > 0)
        ? `${permissionFlag}=${permission.entries?.join(",")}` // --allow-net=["a","b"]
        : permissionFlag; // --allow-net

    const idx = this.parts.findIndex((part) => part.startsWith(permissionFlag));

    if (!permission.allowed) {
      if (idx !== -1) {
        // remove the exisiting permission
        this.parts.splice(idx, 1);
      }
    } else if (permission.allowed) {
      if (idx === -1) {
        // the permission is not there already so put it anywhere
        this.parts.splice(3, 0, finalPermissionForm);
      } else {
        // the permission is there already so we replace it
        this.parts[idx] = finalPermissionForm;
      }
    }
  }

  realPath(): string {
    const urlRegex = /(file:\/\/\/.*?|https:\/\/.*?|jsr:@.*?|npm:.*?)(?=['"])/g;
    const matches = [...this.originalCmd.matchAll(urlRegex)].map((match) =>
      match[1]
    );

    // heuristics:
    // 1. find the last file:// url
    const lastFileUrl = matches.findLast((match) =>
      match.startsWith("file:///")
    );
    if (lastFileUrl) return lastFileUrl;
    // 2. use the last url
    const lastUrl = matches.at(-1);
    assert(
      lastUrl,
      `at lest one url should be present in the script: ${this.originalCmd}`,
    );
    return lastUrl;
  }
}

function* getPrograms() {
  const homeDirPath = homeDir();
  if (!homeDirPath) throw "home dir not found";
  try {
    const programsDir = Deno.readDirSync(
      path.join(homeDirPath, ".deno", "bin"),
    );
    for (const entry of programsDir) {
      if (!entry.isFile) continue;
      yield {
        name: entry.name,
        path: path.join(homeDirPath, ".deno", "bin", entry.name),
      };
    }
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.error("No apps found");
    } else {
      throw e;
    }
  }
}

export async function createProgramMap() {
  const programMap: Record<string, Program> = {};
  for (const entry of getPrograms()) {
    const { name, path } = entry;
    if (await infer.getFromPath(path)?.then((t) => t?.extension()) !== "sh") {
      continue;
    }
    const program = new Program(path);
    programMap[name] = program;
  }
  return programMap;
}

if (import.meta.main) {
  const programMap = await createProgramMap();
  for (const [n, p] of Object.entries(programMap)) {
    console.log(n, p.realPath());
    console.log("read", p.read());
    console.log("write", p.write());
    console.log("run", p.run());
    console.log("net", p.net());
    console.log("all", p.all());
    console.log();
  }
  // programMap.molt.setRead({ allowed: true, entries: ["/etc/hosts"] });
}
